<html>
  <head>
    <title>Psychogeography Analysis</title>
    <link rel="stylesheet" href="analysis.css" media="screen">
    <script src="interval.js"></script>
    <script src="recorded-data.js"></script>
    <script src="signal.js"></script>
    <script src="map.js"></script>
    <script src="selection.js"></script>
    <script src="ace-1.2.5/ace.js"></script>
    <script async defer
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDSAn-W9P0AagulqroPA47vUZrJP-N04Wo">
    </script>    <script id="default-script" type="text/html">/* Create signal processing formulas here.
 * Formulas can be any valid Javascript that returns a number at the end.
 * There are 25 variables formed from combinations of
 * [theta, alpha, low_beta, high_beta, gamma] and
 * [af3, af4, t7, t8, pz] e.g. alpha_af3 or high_beta_pz. */
return theta_af3</script>
  </head>
  <body>
    <div class="head">
      <div id="video-container" class="empty">
        <video src="" id="video" controls="true"></video>
        <div class="drag-instructions">
          Drag video here
        </div>
      </div>
      <div id="data-container" class="empty">
        <div id="controls" class="empty">
          <div class="center">
            <div class="control-row">
              <div class="field">
                <label for="video-start">video start</label>
                <input id="video-start" disabled="true" />
              </div>
              <div class="field">
                <label for="video-sync">sync</label>
                <input id="video-sync" disabled="true"/>
              </div>
              <div class="field">
                <label for="video-end">video end</label>
                <input id="video-end" disabled="true"/>
              </div>
            </div>
            <div class="control-row">
              <div class="field">
                <label for="data-start">data start</label>
                <input id="data-start" disabled="true"/>
              </div>
              <div class="field">
                <label for="data-sync">sync</label>
                <input id="data-sync"/>
              </div>
              <div class="field">
                <label for="data-end">data end</label>
                <input id="data-end" disabled="true"/>
              </div>
            </div>
            <div class="control-row">
            </div>
          </div>
        </div>
        <div id="map"></div>
        <div class="drag-instructions">
          Drag csv data here
        </div>
      </div>
    </div>
    <div id="signals">
      <div id="graphs">
        <div id="marker"></div>
      </div>
      <div id="selection"></div>
      <button id="add-signal">+ add signal</button>
    </div>
    <div id="edit-pane">
      <div id="edit-control">
        <span id="script-error"></span>
        <button class="save">save</button>
        <button class="cancel">cancel</button>
      </div>
      <div id="editor"></div>
    </div>
  </body>
  <script>
  /*
  TODO:
  * More information for csv
  * context and signal processing functions.
  * Automatically set interval to length of video
  * Allow user to set set time at current time in video
  */
    const LAT_SAMPLE = 26;
    const LON_SAMPLE = 27;
    let ipcRenderer;
    let videoPath, dataPath;
    let data = RecordedData();
    let colors = initColors();
    var videoInterval, dataInterval, selectionInterval, viewInterval
    var viewMode = 'intersection';
    let signals = [];
    let currentSignal;
    let editor;
    let selection = Selection(document.querySelector('#graphs'), document.querySelector('#selection'))
    var map;
    initIPC();
    initEditor();
    initDragging();
    selection.addEventListener('click', jumpToTime)
    selection.addEventListener('selection', (d) => console.log("selection", d))
    el('video').addEventListener('timeupdate', timeupdate);
    el('data-sync').addEventListener('blur', updateDataSync);
    el('video-sync').addEventListener('blur', updateVideoSync);
    el('add-signal').addEventListener('click', function() { editSignal() });

    function initIPC() {
      try {
        ipcRenderer = require('electron').ipcRenderer
        ipcRenderer.on('workspace', (e,m) => restoreSaved(m))
        ipcRenderer.on('reset', (e,m) => restoreSaved({}))
        ipcRenderer.on('toolset', (e,m) => setToolset(m))
      } catch (e) { }
    }

    function editSignal(signal) {
      currentSignal = signal;
      editor.setValue(signal ? signal.script : el('default-script').innerHTML);
      editor.clearSelection();
      document.body.setAttribute('class', 'editing');
      el('script-error').innerHTML = '';
      editor.focus();
    }

    function removeSignal(signal) {
      signal.remove();
      signals = signals.filter(function(s) { return s !== signal });
      saveState()
    }

    function updateDataSync() {
      let time = parseTime(el('data-sync').value)
      var date = new Date(dataInterval.start);
      date.setHours(time.h)
      date.setMinutes(time.m)
      date.setSeconds(time.s)
      dataInterval.syncPoint = date.getTime()
      updateRanges()
      updateSignals()
    }

    function updateVideoSync() {
      let time = parseTime(el('video-sync').value)
      videoInterval.syncPoint = 1000*(3600*time.h + 60*time.m + time.s)
      updateRanges()
      updateSignals()
    }

    function updateSignals() {
      signals.forEach(function(signal) { signal.render(data, viewInterval.start, viewInterval.end); })
      saveState();
    }

    function dataLoaded() {
      dataInterval = Interval(data.startTime * 1000, data.endTime * 1000)
      dataInterval.syncPoint = dataInterval.start
      updateRanges()
      refreshSignals();
      saveState()
    }

    function updateRanges() {
      if (videoInterval) {
        el('video-start').value = formatMillis(videoInterval.start)
        el('video-sync').value = formatMillis(videoInterval.syncPoint)
        el('video-end').value = formatMillis(videoInterval.end)
      }

      if (dataInterval) {
        setTime('data-start', dataInterval.start, true)
        setTime('data-sync', dataInterval.syncPoint, true)
        setTime('data-end', dataInterval.end, true)
        if (videoInterval) {
          if (viewMode == 'intersection')
            viewInterval = dataInterval.intersection(videoInterval)
          else
            viewInterval = dataInterval.union(videoInterval)
        } else {
          viewInterval = dataInterval
        }
      }
    }

    function initEditor() {
      editor = ace.edit("editor");
      editor.setTheme("ace/theme/tomorrow_night");
      editor.getSession().setMode("ace/mode/javascript");
      editor.setShowPrintMargin(false);
      editor.getSession().setUseSoftTabs(true);
      editor.setFontSize(12);
      editor.$blockScrolling = Infinity
      editor.commands.addCommand({
          name: 'runScript',
          bindKey: {win: 'Ctrl-Alt-Enter',  mac: 'Ctrl-Alt-Enter'},
          exec: updateScript
      });
      editor.renderer.setPadding(15);
      editor.renderer.setScrollMargin(15);
      editor.clearSelection();
      el('script-error').innerHTML = ''

      document.querySelector('#edit-control .save').addEventListener('click', updateScript);
      document.querySelector('#edit-control .cancel').addEventListener('click', closeEditor);
    }

    function updateScript() {
      try {
        Signal.testScript(editor.getValue());
      } catch (e) {
        el('script-error').innerHTML = e.toString()
        return;
      }
      if (!currentSignal)
        currentSignal = addSignal();
      currentSignal.generateScript(editor.getValue());
      if (viewInterval)
        currentSignal.render(data, viewInterval.start, viewInterval.end);
      closeEditor();
      saveState();
    }

    function closeEditor() {
      document.body.setAttribute('class','');
    }

    function initDragging() {
      const videoContainer = el('video-container')
      videoContainer.ondragover = () => { return false; }
      videoContainer.ondragleave = video.ondragend = () => { return false; }
      videoContainer.ondrop = (e) => {
        e.preventDefault()
        setVideo(e.dataTransfer.files[0].path)
        saveState()
        return false
      }

      const dataContainer = el('data-container')
      dataContainer.ondragover = () => { return false; }
      dataContainer.ondragleave = video.ondragend = () => { return false; }
      dataContainer.ondrop = (e) => {
        e.preventDefault()
        setData(e.dataTransfer.files[0].path);
        return false
      }
    }

    function setVideo(path) {
      videoPath = path
      let video = el('video')
      video.src = videoPath;
      video.addEventListener('durationchange', function() {
        videoInterval = Interval(0, video.duration*1000)
        el('video-sync').removeAttribute('disabled')
        videoInterval.syncPoint = 0
        updateRanges()
      })
      el('video-container').setAttribute('class', videoPath ? '' : 'empty');
    }

    function setData(path) {
      dataPath = path
      data.fetchData(dataPath, dataLoaded);
      el('data-container').setAttribute('class', dataPath ? '' : 'empty');
      map = Map(document.querySelector('#map'))
      if (videoInterval)
        timeupdate()
    }

    function addSignal(color, name) {
      if (!color) color = colors[signals.length%colors.length];
      var signal = Signal(color, 'signal ' + (signals.length+1), name, el('graphs'));
      signal.addEventListener('edit', function() { editSignal(signal) })
      signal.addEventListener('remove', function() { removeSignal(signal); })
      signals.push(signal);
      return signal;
    }

    function jumpToTime(fraction) {
      if (!viewInterval) return
      let time = viewInterval.interp(fraction)

      if (videoInterval) // timeupdate event will move marker
        el('video').currentTime = viewInterval.translateTo(videoInterval, time) / 1000
      else
        markerUpdate(time)
    }

    function timeupdate() {
      if (!viewInterval) return
      var currentTime = videoInterval.translateTo(viewInterval, el('video').currentTime*1000);
      markerUpdate(currentTime)
    }

    function markerUpdate(currentTime) {
      if (!dataInterval) return;

      var timeFraction = viewInterval.fraction(currentTime);
      el('marker').style.left = lerp(0,el('graphs').offsetWidth,timeFraction);

      sample = data.sampleAt(currentTime / 1000);
      let lat = sample[LAT_SAMPLE], lon = sample[LON_SAMPLE];
      if (isNaN(lat) || isNaN(lon)) return;

      map.update(lat, lon)
    }

    function clearSignals() {
      signals = [];
      document.querySelectorAll('.signal').forEach(function(s) {
        s.remove();
      })
    }

    function refreshSignals() {
      signals.forEach((s) => s.render(data, viewInterval.start, viewInterval.end));
    }

    function saveState() {
      var workspace = JSON.stringify({
        videoPath: videoPath,
        dataPath: dataPath,
        viewInterval: viewInterval,
        signals: signals.map(function(s) { return s.serialize() })
      });
      if (ipcRenderer)
        ipcRenderer.send('workspace', workspace);
    }

    function restoreSaved(saved) {
      setVideo(saved.videoPath);
      setData(saved.dataPath);

      startRange = new Date(saved.startRange).getTime();
      setTime('start-range', startRange);
      endRange = new Date(saved.endRange).getTime();
      setTime('end-range', endRange);

      setToolset(saved.signals)
    }

    function setToolset(toolset) {
      toolset = toolset || [];
      clearSignals();
      signals = toolset.map(function(s) {
        var signal = addSignal(s.color, s.name);
        signal.generateScript(s.script);
        if (viewInterval)
          signal.render(data, viewInterval.start, viewInterval.end);
        return signal;
      })
      refreshSignals();
    }

    function hsvToRGBString(h, s, v) {
        var i=(h * 6)|0, f=h * 6 - i, p=v * (1 - s), q=v * (1 - f * s), t=v * (1 - (1 - f) * s);
        switch (i % 6) {
          case 0: return rgbString(v,t,p);
          case 1: return rgbString(q,v,p);
          case 2: return rgbString(p,v,t);
          case 3: return rgbString(p,q,v);
          case 4: return rgbString(t,p,v);
          default: return rgbString(v,p,q);
        }
    }

    function rgbString(r, g, b) {
      return '#' + hex((255*r)|0) + hex((255*g)|0) + hex((255*b)|0);
    }
    function hex(d) {
      return (d < 16 ? '0' : '') + d.toString(16);
    }

    function initColors() {
      for (var i=0, colors = []; i<10; i++) colors.push(hsvToRGBString(i/10, .75, 1));
      return colors;
    }

    function setTime(elId, time) {
      var date = new Date(time);
      if (isNaN(date.getTime()))
        el(elId).value = '';
      else
        el(elId).value = formatFullTime(date);
    }

    function el(id) { return document.getElementById(id); }
    function project(a,b,c,d,x) { return lerp(c,d,prel(a,b,x)) }
    function lerp(a,b,x) { return a + x*(b-a); }
    function prel(a,b,x) { return (x-a)/(b-a); }
    function parseTime(str) {
      var m = str.match(/(\d+):(\d+):(\d+)\s*(AM|PM)?/i)
      if (!m) return {h:0, m:0, s:0}
      return {h: (parseInt(m[1])%12) + (m[4]=='PM'?12:0), m: parseInt(m[2]), s: parseInt(m[3]) }
    }
    function formatMillis(ms) { return Math.floor(ms/3600000) + ':' + pad2(Math.floor(ms/60000)%60) + ':' + pad2(Math.floor(ms/1000)%60) }
    function formatTime(d) { return ((d.getHours()+11)%12+1) + ':' + pad2(d.getMinutes()) + ':' + pad2(d.getSeconds()) }
    function formatFullTime(d) { return formatTime(d) + (d.getHours() >= 12 ? ' PM' : ' AM') }
    function pad2(n) { return (n > 9 ? '' : '0') + n }
  </script>
</html>
