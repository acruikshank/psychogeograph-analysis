<html>
  <head>
    <title>Psychogeography Analysis</title>
    <link rel="stylesheet" href="analysis.css" media="screen">
    <script src="recorded-data.js"></script>
    <script src="signal.js"></script>
    <script src="ace-1.2.5/ace.js"></script>
    <script id="default-script" type="text/html">/* Create signal processing formulas here.
 * Formulas can be any valid Javascript that returns a number at the end.
 * There are 25 variables formed from combinations of
 * [theta, alpha, low_beta, high_beta, gamma] and
 * [af3, af4, t7, t8, pz] e.g. alpha_af3 or high_beta_pz. */
return theta_af3</script>
  </head>
  <body>
    <div class="head">
      <div id="video-container" class="empty">
        <video src="" id="video" controls="true"></video>
        <div class="drag-instructions">
          Drag video here
        </div>
      </div>
      <div id="data-container" class="empty">
        <div id="controls" class="empty">
          <label for="start-range">start range</label>
          <input id="start-range"/>
          <label for="end-range">end range</label>
          <input id="end-range"/>
        </div>
        <div class="drag-instructions">
          Drag csv data here
        </div>
      </div>
    </div>
    <div id="signals">
      <div id="graphs">
        <div id="marker"></div>
      </div>
      <button id="add-signal">add signal</button>
    </div>
    <div id="editor"></div>
  </body>
  <script>
  /*
  TODO:
  * Editor window with save, cancel, error and color change buttons.
  * Drag targets for video and csv window.
  * Responsiveness
  * More information for csv
  * Automatically set interval to length of video
  * Allow user to set set time at current time in video
  */
    let ipcRenderer;
    let videoPath, dataPath;
    let data = RecordedData(dataLoaded);
    let colors = initColors();
    let startRange, endRange;
    let signals = [];
    let currentSignal;
    let editor;
    initIPC();
    initEditor();
    initDragging();
    el('video').addEventListener('timeupdate', timeupdate);
    el('start-range').addEventListener('blur', updateStartRange);
    el('end-range').addEventListener('blur', updateEndRange);
    el('add-signal').addEventListener('click', function() { editSignal() });

    function initIPC() {
      try {
        ipcRenderer = require('electron').ipcRenderer
        ipcRenderer.on('workspace', (e,m) => restoreSaved(m))
        ipcRenderer.on('reset', (e,m) => restoreSaved({}))
        ipcRenderer.on('toolset', (e,m) => setToolset(m))
      } catch (e) { }
    }

    function editSignal(signal) {
      currentSignal = signal;
      editor.setValue(signal ? signal.script : el('default-script').innerHTML);
      editor.clearSelection();
      document.body.setAttribute('class', 'editing');
      editor.focus();
    }

    function removeSignal(signal) {
      signal.remove();
      signals = signals.filter(function(s) { return s !== signal });
      saveState()
    }

    function updateStartRange() {
      var next = new Date(el('start-range').value);
      if (isNaN(next.getTime()))
        return setTime('start-range', next.getTime())

      startRange = next.getTime();
      updateSignals();
    }

    function updateEndRange() {
      var next = new Date(el('end-range').value);
      if (isNaN(next.getTime()))
        return setTime('end-range', next.getTime())

      endRange = next.getTime();
      updateSignals();
    }

    function updateSignals() {
      signals.forEach(function(signal) { signal.render(startRange, endRange); })
      saveState();
    }

    function setTime(elId, time) {
      var date = new Date(time);
      if (isNaN(date.getTime()))
        el(elId).value = '';
      else
        el(elId).value = date.toLocaleString();
    }

    function dataLoaded() {
      if (!startRange) {
        startRange = 1000 * data.startTime
        setTime('start-range', startRange)
      }

      if (!endRange) {
        endRange = 1000 * data.endTime;
        setTime('end-range', endRange)
      }
      refreshSignals();
      saveState()
    }

    function initEditor() {
      editor = ace.edit("editor");
      editor.setTheme("ace/theme/tomorrow_night");
      editor.getSession().setMode("ace/mode/javascript");
      editor.setShowPrintMargin(false);
      editor.getSession().setUseSoftTabs(true);
      editor.setFontSize(12);
      editor.commands.addCommand({
          name: 'runScript',
          bindKey: {win: 'Ctrl-Alt-Enter',  mac: 'Ctrl-Alt-Enter'},
          exec: updateScript
      });
      editor.renderer.setPadding(15);
      editor.renderer.setScrollMargin(15);
      editor.clearSelection();
    }

    function initDragging() {
      const videoContainer = el('video-container')
      videoContainer.ondragover = () => { return false; }
      videoContainer.ondragleave = video.ondragend = () => { return false; }
      videoContainer.ondrop = (e) => {
        e.preventDefault()
        setVideo(e.dataTransfer.files[0].path)
        saveState()
        return false
      }

      const dataContainer = el('data-container')
      dataContainer.ondragover = () => { return false; }
      dataContainer.ondragleave = video.ondragend = () => { return false; }
      dataContainer.ondrop = (e) => {
        e.preventDefault()
        setData(e.dataTransfer.files[0].path);
        return false
      }
    }

    function setVideo(path) {
      videoPath = path
      el('video').src = videoPath;
      el('video-container').setAttribute('class', videoPath ? '' : 'empty');
    }

    function setData(path) {
      dataPath = path
      data.fetchData(dataPath);
      el('data-container').setAttribute('class', dataPath ? '' : 'empty');
    }

    function updateScript() {
      if (!currentSignal)
        currentSignal = addSignal();
      currentSignal.generateScript(editor.getValue());
      currentSignal.render(startRange, endRange);
      document.body.setAttribute('class','');
      saveState();
    }

    function addSignal(color) {
      if (!color) color = colors[signals.length%colors.length];
      var signal = Signal(color, el('graphs'));
      signal.addEventListener('edit', function() { editSignal(signal) })
      signal.addEventListener('remove', function() { removeSignal(signal); })
      signals.push(signal);
      return signal;
    }

    function timeupdate(e) {
      var canvas = el('c');
      // TODO: need new number for calibration
      var currentTime = startRange + el('video').currentTime*1000;
      var timeFraction = prel(startRange,endRange, currentTime);
      el('marker').style.left = lerp(0,el('graphs').offsetWidth,timeFraction);
    }

    function clearSignals() {
      signals = [];
      document.querySelectorAll('.signal').forEach(function(s) {
        s.remove();
      })
    }

    function refreshSignals() {
      signals.forEach((s) => s.render(startRange, endRange));
    }

    function saveState() {
      var workspace = JSON.stringify({
        videoPath: videoPath,
        dataPath: dataPath,
        startRange: startRange,
        endRange: endRange,
        signals: signals.map(function(s) { return s.serialize() })
      });
      if (ipcRenderer)
        ipcRenderer.send('workspace', workspace);
    }

    function restoreSaved(saved) {
      setVideo(saved.videoPath);
      setData(saved.dataPath);

      startRange = new Date(saved.startRange).getTime();
      setTime('start-range', startRange);
      endRange = new Date(saved.endRange).getTime();
      setTime('end-range', endRange);

      setToolset(saved.signals)
    }

    function setToolset(toolset) {
      toolset = toolset || [];
      clearSignals();
      signals = toolset.map(function(s) {
        var signal = addSignal(s.color);
        signal.generateScript(s.script);
        signal.render(startRange, endRange);
        return signal;
      })
      refreshSignals();
    }

    function hsvToRGBString(h, s, v) {
        var i=(h * 6)|0, f=h * 6 - i, p=v * (1 - s), q=v * (1 - f * s), t=v * (1 - (1 - f) * s);
        switch (i % 6) {
          case 0: return rgbString(v,t,p);
          case 1: return rgbString(q,v,p);
          case 2: return rgbString(p,v,t);
          case 3: return rgbString(p,q,v);
          case 4: return rgbString(t,p,v);
          default: return rgbString(v,p,q);
        }
    }

    function rgbString(r, g, b) {
      return '#' + hex((255*r)|0) + hex((255*g)|0) + hex((255*b)|0);
    }
    function hex(d) {
      return (d < 16 ? '0' : '') + d.toString(16);
    }

    function initColors() {
      for (var i=0, colors = []; i<10; i++) colors.push(hsvToRGBString(i/10, .75, 1));
      return colors;
    }

    function el(id) { return document.getElementById(id); }
    function project(a,b,c,d,x) { return lerp(c,d,prel(a,b,x)) }
    function lerp(a,b,x) { return a + x*(b-a); }
    function prel(a,b,x) { return (x-a)/(b-a); }
  </script>
</html>
