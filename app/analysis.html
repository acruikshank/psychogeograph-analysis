<html>
  <head>
    <title>Psychogeography Analysis</title>
    <link rel="stylesheet" href="analysis.css" media="screen">
    <script src="interval.js"></script>
    <script src="recorded-data.js"></script>
    <script src="signal.js"></script>
    <script src="map.js"></script>
    <script src="selection.js"></script>
    <script src="ace-1.2.5/ace.js"></script>
    <script async defer
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDSAn-W9P0AagulqroPA47vUZrJP-N04Wo">
    </script>    <script id="default-script" type="text/html">/* Create signal processing formulas here.
 * Formulas can be any valid Javascript that returns a number at the end.
 * There are 25 variables formed from combinations of
 * [theta, alpha, low_beta, high_beta, gamma] and
 * [af3, af4, t7, t8, pz] e.g. alpha_af3 or high_beta_pz. */
return theta_af3</script>
  </head>
  <body>
    <div class="head">
      <div id="video-container" class="empty">
        <video src="" id="video" controls="true"></video>
        <div class="drag-instructions">
          Drag video here
        </div>
      </div>
      <div id="data-container" class="empty">
        <div id="controls" class="empty">
          <div class="center">
            <div class="control-row">
              <div class="field">
                <label for="video-start">video start</label>
                <input id="video-start"/>
              </div>
              <div class="field">
                <label for="video-end">video end</label>
                <input id="video-end"/>
              </div>
            </div>
            <div class="control-row">
            </div>
          </div>
        </div>
        <div id="map"></div>
        <div class="drag-instructions">
          Drag csv data here
        </div>
      </div>
    </div>
    <div id="signals">
      <div id="selection"></div>
      <div id="graphs">
        <div id="marker"></div>
      </div>
      <button id="add-signal">+ add signal</button>
    </div>
    <div id="edit-pane">
      <div id="edit-control">
        <span id="script-error"></span>
        <button class="save">save</button>
        <button class="cancel">cancel</button>
      </div>
      <div id="editor"></div>
    </div>
  </body>
  <script>
  /*
  TODO:
  * More information for csv
  * context and signal processing functions.
  * Automatically set interval to length of video
  * Allow user to set set time at current time in video
  */
    const LAT_SAMPLE = 26;
    const LON_SAMPLE = 27;
    let ipcRenderer;
    let videoPath, dataPath;
    let data = RecordedData(dataLoaded);
    let colors = initColors();
    var videoInterval, dataInterval, selectionInterval, viewInterval
    var startRange, endRange
    let signals = [];
    let currentSignal;
    let editor;
    let selection = Selection(document.querySelector('#graphs'), document.querySelector('#selection'))
    var map;
    initIPC();
    initEditor();
    initDragging();
    selection.addEventListener('click', jumpToTime)
    selection.addEventListener('selection', (d) => console.log("selection", d))
    el('video').addEventListener('timeupdate', timeupdate);
    el('video-start').addEventListener('blur', updateStartRange);
    el('video-end').addEventListener('blur', updateEndRange);
    el('add-signal').addEventListener('click', function() { editSignal() });

    function initIPC() {
      try {
        ipcRenderer = require('electron').ipcRenderer
        ipcRenderer.on('workspace', (e,m) => restoreSaved(m))
        ipcRenderer.on('reset', (e,m) => restoreSaved({}))
        ipcRenderer.on('toolset', (e,m) => setToolset(m))
      } catch (e) { }
    }

    function editSignal(signal) {
      currentSignal = signal;
      editor.setValue(signal ? signal.script : el('default-script').innerHTML);
      editor.clearSelection();
      document.body.setAttribute('class', 'editing');
      el('script-error').innerHTML = '';
      editor.focus();
    }

    function removeSignal(signal) {
      signal.remove();
      signals = signals.filter(function(s) { return s !== signal });
      saveState()
    }

    function updateStartRange() {
      var next = new Date(el('video-start').value);
      if (isNaN(next.getTime()))
        return setTime('video-start', startRange)

      startRange = next.getTime();
      updateSignals();
    }

    function updateEndRange() {
      var next = new Date(el('video-end').value);
      if (isNaN(next.getTime()))
        return setTime('video-end', endRange)

      endRange = next.getTime();
      updateSignals();
    }

    function updateSignals() {
      signals.forEach(function(signal) { signal.render(data, startRange, endRange); })
      saveState();
    }

    function setTime(elId, time) {
      var date = new Date(time);
      if (isNaN(date.getTime()))
        el(elId).value = '';
      else
        el(elId).value = date.toLocaleString();
    }

    function dataLoaded() {
      updateRanges()
      refreshSignals();
      saveState()
    }

    function updateRanges() {
      startRange = 1000 * data.startTime
      setTime('video-start', startRange)

      endRange = 1000 * data.endTime;
      setTime('video-end', endRange)
    }

    function initEditor() {
      editor = ace.edit("editor");
      editor.setTheme("ace/theme/tomorrow_night");
      editor.getSession().setMode("ace/mode/javascript");
      editor.setShowPrintMargin(false);
      editor.getSession().setUseSoftTabs(true);
      editor.setFontSize(12);
      editor.commands.addCommand({
          name: 'runScript',
          bindKey: {win: 'Ctrl-Alt-Enter',  mac: 'Ctrl-Alt-Enter'},
          exec: updateScript
      });
      editor.renderer.setPadding(15);
      editor.renderer.setScrollMargin(15);
      editor.clearSelection();
      el('script-error').innerHTML = ''

      document.querySelector('#edit-control .save').addEventListener('click', updateScript);
      document.querySelector('#edit-control .cancel').addEventListener('click', closeEditor);
    }

    function updateScript() {
      try {
        Signal.testScript(editor.getValue());
      } catch (e) {
        el('script-error').innerHTML = e.toString()
        return;
      }
      if (!currentSignal)
        currentSignal = addSignal();
      currentSignal.generateScript(editor.getValue());
      currentSignal.render(data, startRange, endRange);
      closeEditor();
      saveState();
    }

    function closeEditor() {
      document.body.setAttribute('class','');
    }

    function initDragging() {
      const videoContainer = el('video-container')
      videoContainer.ondragover = () => { return false; }
      videoContainer.ondragleave = video.ondragend = () => { return false; }
      videoContainer.ondrop = (e) => {
        e.preventDefault()
        setVideo(e.dataTransfer.files[0].path)
        saveState()
        return false
      }

      const dataContainer = el('data-container')
      dataContainer.ondragover = () => { return false; }
      dataContainer.ondragleave = video.ondragend = () => { return false; }
      dataContainer.ondrop = (e) => {
        e.preventDefault()
        setData(e.dataTransfer.files[0].path);
        return false
      }
    }

    function setVideo(path) {
      videoPath = path
      el('video').src = videoPath;
      el('video-container').setAttribute('class', videoPath ? '' : 'empty');
    }

    function setData(path) {
      dataPath = path
      data.fetchData(dataPath);
      el('data-container').setAttribute('class', dataPath ? '' : 'empty');
      map = Map(document.querySelector('#map'))
      timeupdate()
    }

    function addSignal(color) {
      if (!color) color = colors[signals.length%colors.length];
      var signal = Signal(color, el('graphs'));
      signal.addEventListener('edit', function() { editSignal(signal) })
      signal.addEventListener('remove', function() { removeSignal(signal); })
      signals.push(signal);
      return signal;
    }

    function jumpToTime(fraction) {
      let video = el('video')
      let duration = video ? video.duration : (data.endTime - data.startTime) * 1000

      timeFraction = prel(0, duration, lerp(0, (endRange - startRange)/1000, fraction))
      console.log(duration, fraction, timeFraction)
      el('video').currentTime = duration * timeFraction
    }

    function timeupdate() {
      // TODO: need new number for calibration
      var currentTime = startRange + el('video').currentTime*1000;
      var timeFraction = prel(startRange,endRange, currentTime);
      el('marker').style.left = lerp(0,el('graphs').offsetWidth,timeFraction);

      if (!data.samples) return;

      sample = data.sampleAt(currentTime / 1000);
      let lat = sample[LAT_SAMPLE], lon = sample[LON_SAMPLE];
      console.log('lat',lat, 'lon', lon)
      if (isNaN(lat) || isNaN(lon)) return;

      map.update(lat, lon)
    }

    function clearSignals() {
      signals = [];
      document.querySelectorAll('.signal').forEach(function(s) {
        s.remove();
      })
    }

    function refreshSignals() {
      signals.forEach((s) => s.render(data, startRange, endRange));
    }

    function saveState() {
      var workspace = JSON.stringify({
        videoPath: videoPath,
        dataPath: dataPath,
        startRange: startRange,
        endRange: endRange,
        signals: signals.map(function(s) { return s.serialize() })
      });
      if (ipcRenderer)
        ipcRenderer.send('workspace', workspace);
    }

    function restoreSaved(saved) {
      setVideo(saved.videoPath);
      setData(saved.dataPath);

      startRange = new Date(saved.startRange).getTime();
      setTime('start-range', startRange);
      endRange = new Date(saved.endRange).getTime();
      setTime('end-range', endRange);

      setToolset(saved.signals)
    }

    function setToolset(toolset) {
      toolset = toolset || [];
      clearSignals();
      signals = toolset.map(function(s) {
        var signal = addSignal(s.color);
        signal.generateScript(s.script);
        signal.render(data, startRange, endRange);
        return signal;
      })
      refreshSignals();
    }

    function hsvToRGBString(h, s, v) {
        var i=(h * 6)|0, f=h * 6 - i, p=v * (1 - s), q=v * (1 - f * s), t=v * (1 - (1 - f) * s);
        switch (i % 6) {
          case 0: return rgbString(v,t,p);
          case 1: return rgbString(q,v,p);
          case 2: return rgbString(p,v,t);
          case 3: return rgbString(p,q,v);
          case 4: return rgbString(t,p,v);
          default: return rgbString(v,p,q);
        }
    }

    function rgbString(r, g, b) {
      return '#' + hex((255*r)|0) + hex((255*g)|0) + hex((255*b)|0);
    }
    function hex(d) {
      return (d < 16 ? '0' : '') + d.toString(16);
    }

    function initColors() {
      for (var i=0, colors = []; i<10; i++) colors.push(hsvToRGBString(i/10, .75, 1));
      return colors;
    }

    function el(id) { return document.getElementById(id); }
    function project(a,b,c,d,x) { return lerp(c,d,prel(a,b,x)) }
    function lerp(a,b,x) { return a + x*(b-a); }
    function prel(a,b,x) { return (x-a)/(b-a); }
  </script>
</html>
